package elo

import (
	"fmt"
	"regexp"
	"strconv"
	"time"

	"github.com/wlbr/commons/log"
)

type Event interface {
	String() string
}

type BaseEvent struct {
	Server  *Server
	Time    time.Time
	Message string
}

func NewBaseEvent(server *Server, timestamp time.Time, message string) *BaseEvent {
	e := &BaseEvent{Server: server, Time: timestamp, Message: message}
	log.Info("Created event: %+v", e)
	return e
}

type KillEvent struct {
	BaseEvent
	Subject         *Player
	subjectPosition string
	subjectTeam     string
	Object          *Player
	objectPosition  string
	objectTeam      string
	weapon          string
	Headshot        bool
}

//"Madlen<221><BOT><CT>" [2650 -3117 -130] killed "Franzi<216><BOT><TERRORIST>" [3649 -3151 -48] with "hkp2000"
//"KiF Charlies Silence<16><STEAM_1:0:710013><TERRORIST>" [3878 -2315 -102] killed "Steffi<219><BOT><CT>" [2762 -4031 -142] with "sg556" (headshot)
var killrex = regexp.MustCompile(`^"(.+)<(.+)><(.+)><(.+)>" \[(.+)\] killed "(.+)<(.+)><(.+)><(.+)>" \[(.+)\] with "(.+)"( \((headshot)\))?$`)

func NewKillEvent(server *Server, t time.Time, message string) (e *KillEvent) {
	if sm := killrex.FindStringSubmatch(message); sm != nil {
		headshot := len(sm) >= 14 && sm[13] == "headshot"

		e = &KillEvent{Subject: GetPlayer(sm[1], sm[3]), subjectTeam: sm[4], subjectPosition: sm[5],
			Object: GetPlayer(sm[6], sm[8]), objectTeam: sm[9], objectPosition: sm[10],
			weapon: sm[11], Headshot: headshot,
			BaseEvent: BaseEvent{Time: t, Server: server, Message: message}}
		log.Info("Created event: %+v", e)
	}
	return e
}

func (e *KillEvent) String() (s string) {
	s = fmt.Sprintf("Kill %s ==> %s ", e.Subject, e.Object)
	if e.Headshot {
		s = s + "(headshot) "
	}
	s = s + e.Time.String()
	return s
}

//"Tina<217><BOT><CT>" assisted killing "Franzi<216><BOT><TERRORIST>"
//"Jagger<19><STEAM_1:0:681607><TERRORIST>" assisted killing "AHA<199><STEAM_1:1:689719><CT>"
var assistrex = regexp.MustCompile(`^"(.+)<(.+)><(.+)><(.+)>" assisted killing "(.+)<(.+)><(.+)><(.+)>"$`)

type AssistEvent struct {
	BaseEvent
	Subject     *Player
	subjectTeam string
	Object      *Player
	objectTeam  string
}

func NewAssistEvent(server *Server, t time.Time, message string) (e *AssistEvent) {
	if sm := assistrex.FindStringSubmatch(message); sm != nil {
		e = &AssistEvent{Subject: &Player{Name: sm[1], SteamID: sm[3]}, subjectTeam: sm[4],
			Object: &Player{Name: sm[5], SteamID: sm[7]}, objectTeam: sm[8],
			BaseEvent: BaseEvent{Time: t, Server: server, Message: message}}
		log.Info("Created event: %+v", e)
	}
	return e
}

func (e *AssistEvent) String() string {
	return fmt.Sprintf("Assist %s ==> %s", e.Subject, e.Object)
}

//"Das Schnitzel<214><BOT><CT>" blinded for 2.39 by "Tina<217><BOT><CT>" from flashbang entindex 156
//"Jagger<19><STEAM_1:0:681607><TERRORIST>" blinded for 4.18 by "Dackel<2><STEAM_1:0:1770206><CT>" from flashbang entindex 209
var blindedrex = regexp.MustCompile(`^"(.+)<(.+)><(.+)><(.+)>" blinded for (.+) by "(.+)<(.+)><(.+)><(.+)>" from flashbang entindex (\d+).*$`)

type BlindedEvent struct {
	BaseEvent
	Subject     *Player
	subjectTeam string
	Object      *Player
	objectTeam  string
	flashentity int
	Duration    float64
}

func NewBlindedEvent(server *Server, t time.Time, message string) (e *BlindedEvent) {
	if sm := blindedrex.FindStringSubmatch(message); sm != nil {
		dur, err1 := strconv.ParseFloat(sm[5], 32)
		if err1 != nil {
			log.Error("Flash duration not a float. %s, message: \"%s\"", err1, message)
		}
		ent, err2 := strconv.Atoi(sm[10])
		if err2 != nil {
			log.Error("Entity number not a int. %s, message: \"%s\" %v", err2, message, ent)
		}
		if err1 == nil && err2 == nil {
			e = &BlindedEvent{Subject: &Player{Name: sm[6], SteamID: sm[8]}, subjectTeam: sm[9],
				Object: &Player{Name: sm[1], SteamID: sm[3]}, objectTeam: sm[4],
				Duration: dur, flashentity: ent,
				BaseEvent: BaseEvent{Time: t, Server: server, Message: message}}
		}
		log.Info("Created event: %+v", e)
	}
	return e
}

func (e *BlindedEvent) String() string {
	s := fmt.Sprintf("Blinded %s ==> %s", e.Subject, e.Object)

	return s
}

func (e *BlindedEvent) OwnTeam() bool {
	if e.subjectTeam == e.objectTeam {
		return true
	}
	return false
}

type GrenadeEvent struct {
	BaseEvent
	Subject     *Player
	subjectTeam string
	position    string
	GrenadeType string
	flashentity int
}

//"Jagger<19><STEAM_1:0:681607><TERRORIST>" threw flashbang [808 -247 -627] flashbang entindex 150)
//"Jagger<19><STEAM_1:0:681607><CT>" threw hegrenade [1303 -496 -638]
//"KiF Charlies Silence<16><STEAM_1:0:710013><TERRORIST>" threw smokegrenade [906 -291 -638]
//"AHA<199><STEAM_1:1:689719><CT>" threw molotov [1020 -969 -766]
var grenadedrex = regexp.MustCompile(`^"(.+)<(.+)><(.+)><(.+)>" threw (.+) \[.+\]((.+) entindex (.+)\))?$`)

func NewGrenadeEvent(server *Server, t time.Time, message string) (e *GrenadeEvent) {
	if sm := grenadedrex.FindStringSubmatch(message); sm != nil {
		gtype := sm[5]
		entity := 0
		if gtype == "flashbang" {
			var err error
			entity, err = strconv.Atoi(sm[8])
			if err != nil {
				log.Error("Entity number not a int. Error: '%s', message: '%s'", err, message)
			}
		}
		e = &GrenadeEvent{Subject: &Player{Name: sm[1], SteamID: sm[3]}, subjectTeam: sm[4],
			GrenadeType: gtype, position: sm[6], flashentity: entity,
			BaseEvent: BaseEvent{Time: t, Server: server, Message: message}}
		log.Info("Created event: %+v", e)
	}
	return e
}

func (e *GrenadeEvent) String() string {
	return fmt.Sprintf("%s throws grenade %s", e.Subject, e.GrenadeType)
}

type PlantedEvent struct {
	BaseEvent
	Subject     *Player
	subjectTeam string
}

//"AHA<18><STEAM_1:1:689719><TERRORIST>" triggered "Planted_The_Bomb"
var plantedrex = regexp.MustCompile(`^"(.+)<(.+)><(.+)><(.+)>" triggered "Planted_The_Bomb"$`)
var lastplanter *Player

func NewPlantedEvent(server *Server, t time.Time, message string) (e *PlantedEvent) {
	if sm := plantedrex.FindStringSubmatch(message); sm != nil {
		pl := &Player{Name: sm[1], SteamID: sm[3]}
		lastplanter = pl
		e = &PlantedEvent{Subject: pl, subjectTeam: sm[4],
			BaseEvent: BaseEvent{Time: t, Server: server, Message: message}}
		log.Info("Created event: %+v", e)
	}
	return e
}

func (e *PlantedEvent) String() string {
	return fmt.Sprintf("Bomb planted by %s", e.Subject)
}

type DefuseEvent struct {
	BaseEvent
	Subject     *Player
	subjectTeam string
}

//"Jagger<19><STEAM_1:0:681607><CT>" triggered "Defused_The_Bomb"
var defusedrex = regexp.MustCompile(`^"(.+)<(.+)><(.+)><(.+)>" triggered "Defused_The_Bomb"$`)

func NewDefuseEvent(server *Server, t time.Time, message string) (e *DefuseEvent) {
	if sm := defusedrex.FindStringSubmatch(message); sm != nil {
		e = &DefuseEvent{Subject: &Player{Name: sm[1], SteamID: sm[3]}, subjectTeam: sm[4],
			BaseEvent: BaseEvent{Time: t, Server: server, Message: message}}
		log.Info("Created event: %+v", e)
	}
	return e
}

func (e *DefuseEvent) String() string {
	return fmt.Sprintf("Bomb defused by %s", e.Subject)
}

type BombedEvent struct {
	BaseEvent
	Subject     *Player
	subjectTeam string
}

func NewBombedEvent(server *Server, t time.Time, message string) (e *BombedEvent) {
	if sm := bombeddrex.FindStringSubmatch(message); sm != nil {
		e = &BombedEvent{Subject: lastplanter, subjectTeam: sm[1],
			BaseEvent: BaseEvent{Time: t, Server: server, Message: message}}
		log.Info("Created event: %+v", e)
	}
	return e
}

//Team "TERRORIST" triggered "SFUI_Notice_Target_Bombed" (CT "2") (T "2")
var bombeddrex = regexp.MustCompile(`Team "(.+)" triggered "SFUI_Notice_Target_Bombed" \((.+) "(.+)"\) \((.+) "(.+)"\)`)

func (e *BombedEvent) String() string {
	return fmt.Sprintf("Bomb exploded, planted by %s", e.Subject)
}

type HostageRescuedEvent struct {
	BaseEvent
	Subject     *Player
	subjectTeam string
}

//"Jagger<19><STEAM_1:0:681607><CT>" triggered "Rescued_A_Hostage"
var rescuedrex = regexp.MustCompile(`^"(.+)<(.+)><(.+)><(.+)>" triggered "Rescued_A_Hostage"$`)

func NewHostageRescuedEvent(server *Server, t time.Time, message string) (e *HostageRescuedEvent) {
	if sm := rescuedrex.FindStringSubmatch(message); sm != nil {
		e = &HostageRescuedEvent{Subject: &Player{Name: sm[1], SteamID: sm[3]}, subjectTeam: sm[4],
			BaseEvent: BaseEvent{Time: t, Server: server, Message: message}}
		log.Info("Created event: %+v", e)
	}
	return e
}

func (e *HostageRescuedEvent) String() string {
	return fmt.Sprintf("Hostage rescued by %s", e.Subject)
}

type RoundStartEvent struct {
	BaseEvent
}

//World triggered "Round_Start"
var roundstartdrex = regexp.MustCompile(`^World triggered "Round_Start"$`)

func NewRoundStartEvent(server *Server, t time.Time, message string) (e *RoundStartEvent) {
	if sm := roundstartdrex.FindStringSubmatch(message); sm != nil {
		e = &RoundStartEvent{BaseEvent: BaseEvent{Time: t, Server: server, Message: message}}
		log.Info("Created event: %+v", e)
	}
	return e
}

func (e *RoundStartEvent) String() string {
	return fmt.Sprintf("Round start at %s", e.Time.Format(time.RFC822Z))
}

type RoundEndEvent struct {
	BaseEvent
	subject *Player
}

//World triggered "Round_End"
var roundendedrex = regexp.MustCompile(`^World triggered "Round_End"$`)

func NewRoundEndEvent(server *Server, t time.Time, message string) (e *RoundEndEvent) {
	if sm := roundstartdrex.FindStringSubmatch(message); sm != nil {
		e = &RoundEndEvent{BaseEvent: BaseEvent{Time: t, Server: server, Message: message}}
		log.Info("Created event: %+v", e)
	}
	return e
}

func (e *RoundEndEvent) String() string {
	return fmt.Sprintf("Round end at %s", e.Time.Format(time.RFC822Z))
}

type MatchStartEvent struct {
	BaseEvent
}

//World triggered "Match_Start" on "de_lake"
var matchstartrex = regexp.MustCompile(`^World triggered "Match_Start".+$`)

func NewMatchStartEvent(server *Server, t time.Time, message string) (e *MatchStartEvent) {
	if sm := matchstartrex.FindStringSubmatch(message); sm != nil {
		e = &MatchStartEvent{BaseEvent: BaseEvent{Time: t, Server: server, Message: message}}
		log.Info("Created event: %+v", e)
	}
	return e
}

func (e *MatchStartEvent) String() string {
	return fmt.Sprintf("Match start at %s", e.Time.Format(time.RFC822Z))
}

type MatchEndEvent struct {
	BaseEvent
	Duration time.Duration
	CtScore  int
	TScore   int
}

//Game Over: competitive default cs_office score 8:4 after 12 min
var matchendtrex = regexp.MustCompile(`^Game Over.+score (.+):(.+) after (.+) (.+)$`)

func NewMatchEndEvent(server *Server, t time.Time, message string) (e *MatchEndEvent) {
	if sm := matchendtrex.FindStringSubmatch(message); sm != nil {
		cts, err1 := strconv.Atoi(sm[1])
		ts, err2 := strconv.Atoi(sm[2])
		d, err3 := time.ParseDuration(sm[3] + sm[4][0:1])
		if err1 != nil || err2 != nil || err3 != nil {
			log.Error("Malformed match end event: %s", message)
		} else {
			e = &MatchEndEvent{Duration: d, CtScore: cts, TScore: ts, BaseEvent: BaseEvent{Time: t, Server: server, Message: message}}
			log.Info("Created event: %+v", e)
		}
	}
	return e
}

func (e *MatchEndEvent) String() string {
	return fmt.Sprintf("Match end at %s, %d:%d, %s", e.Time.Format(time.RFC822Z), e.CtScore, e.TScore, e.Duration)
}
